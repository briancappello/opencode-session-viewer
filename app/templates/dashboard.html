<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenCode Sessions</title>
    <link rel="stylesheet" href="/static/css/base.css" />
    <link rel="stylesheet" href="/static/css/dashboard.css" />
  </head>
  <body>
    <div class="container">
      <div class="header">
        <div class="title">OpenCode Sessions</div>
        <div class="controls">
          <a href="/archived" class="toggle-btn" title="View archived sessions"
            >Archived</a
          >
          <a
            href="/?all={{ 'false' if show_all else 'true' }}"
            class="toggle-btn {{ 'active' if show_all }}"
          >
            {{ 'Hide Subagents' if show_all else 'Show All' }}
          </a>
          <button
            class="theme-toggle"
            onclick="toggleTheme()"
            title="Toggle dark mode"
          >
            ðŸŒ“
          </button>
        </div>
      </div>

      <div class="search-container">
        <input
          type="text"
          id="searchInput"
          class="search-input"
          placeholder="Search session contents..."
        />
        <select id="directorySelect" class="directory-select">
          <option value="">All directories</option>
        </select>
        <button onclick="performSearch()" class="search-btn" id="searchBtn">
          Search
        </button>
        <button onclick="syncIndex()" class="sync-btn" id="syncBtn">
          Sync
        </button>
        <button onclick="clearSearch()" class="clear-btn hidden" id="clearBtn">
          Clear
        </button>
      </div>
      <div class="search-options">
        <label class="checkbox-label">
          <input type="checkbox" id="regexCheckbox" />
          <span>Use regular expression</span>
        </label>
      </div>

      <div id="searchResultsHeader" class="search-results-header hidden">
        <span id="searchResultsCount"></span>
      </div>

      <div class="session-list" id="sessionList">
        {% for session in sessions %}
          <div class="session-item" data-session-id="{{ session.id }}">
            <a href="/session/{{ session.id }}" class="session-item-link">
              <div class="session-header">
                <div class="session-title">
                  {{ session.title or "Untitled" }}
                </div>
                <div class="session-time">{{ session.updated_formatted }}</div>
              </div>
              <div class="session-meta">
                <div class="meta-item">
                  <span>ðŸ“‚</span>
                  <span class="directory" title="{{ session.directory }}"
                    >{{ session.directory_short }}</span
                  >
                </div>
                {% if session.model %}
                  <div class="meta-item">
                    <span>ðŸ¤–</span>
                    <span>{{ session.model }}</span>
                  </div>
                {% endif %}
                <div class="meta-item">
                  <span style="color: var(--text-tertiary)"
                    >ID: {{ session.id }}</span
                  >
                </div>
              </div>
            </a>
            <a
              href="#"
              class="archive-link"
              onclick="archiveSession('{{ session.id }}', event)"
              >Archive</a
            >
          </div>
        {% else %}
          <div class="empty-state">No sessions found.</div>
        {% endfor %}
      </div>
    </div>

    <script>
      // Theme
      function toggleTheme() {
        document.body.classList.toggle("dark");
        localStorage.setItem(
          "theme",
          document.body.classList.contains("dark") ? "dark" : "light",
        );
      }

      // Init theme
      if (localStorage.getItem("theme") === "dark") {
        document.body.classList.add("dark");
      } else if (
        !localStorage.getItem("theme") &&
        window.matchMedia("(prefers-color-scheme: dark)").matches
      ) {
        document.body.classList.add("dark");
      }

      // Search functionality
      const searchInput = document.getElementById("searchInput");
      const directorySelect = document.getElementById("directorySelect");
      const regexCheckbox = document.getElementById("regexCheckbox");
      const searchBtn = document.getElementById("searchBtn");
      const clearBtn = document.getElementById("clearBtn");
      const sessionList = document.getElementById("sessionList");
      const searchResultsHeader = document.getElementById(
        "searchResultsHeader",
      );
      const searchResultsCount = document.getElementById("searchResultsCount");

      // Store original content
      const originalContent = sessionList.innerHTML;

      // Update placeholder when regex checkbox changes
      regexCheckbox.addEventListener("change", () => {
        searchInput.placeholder = regexCheckbox.checked
          ? "Search with regex pattern..."
          : "Search session contents...";
      });

      // Load directories on page load
      async function loadDirectories() {
        try {
          const response = await fetch("/api/directories");
          const directories = await response.json();
          directories.forEach((dir) => {
            const option = document.createElement("option");
            option.value = dir;
            // Shorten for display
            const shortDir = dir.length > 50 ? "..." + dir.slice(-47) : dir;
            option.textContent = shortDir;
            option.title = dir;
            directorySelect.appendChild(option);
          });
        } catch (e) {
          console.error("Failed to load directories:", e);
        }
      }

      async function performSearch() {
        const query = searchInput.value.trim();
        const directory = directorySelect.value;
        const useRegex = regexCheckbox.checked;

        if (!query && !directory) {
          return;
        }

        searchBtn.disabled = true;
        searchBtn.textContent = "Searching...";

        try {
          const params = new URLSearchParams();
          if (query) params.set("q", query);
          if (directory) params.set("directory", directory);
          if (useRegex) params.set("regex", "true");

          // If no query but directory selected, use wildcard (only for non-regex)
          if (!query && directory && !useRegex) {
            params.set("q", "*");
          }

          const response = await fetch("/api/search?" + params.toString());
          const results = await response.json();

          displaySearchResults(results, query, useRegex);
        } catch (e) {
          console.error("Search failed:", e);
          sessionList.innerHTML =
            '<div class="empty-state">Search failed. Please try again.</div>';
        } finally {
          searchBtn.disabled = false;
          searchBtn.textContent = "Search";
        }
      }

      function displaySearchResults(results, query, useRegex = false) {
        clearBtn.classList.remove("hidden");
        searchResultsHeader.classList.remove("hidden");
        const searchType = useRegex ? "regex" : "plaintext";
        searchResultsCount.textContent = `Found ${results.length} session${results.length !== 1 ? "s" : ""} matching "${query}" (${searchType})`;

        if (results.length === 0) {
          const hint = useRegex
            ? "Check your regex pattern syntax."
            : "Try different search terms.";
          sessionList.innerHTML = `<div class="empty-state">No sessions found matching your search. ${hint}</div>`;
          return;
        }

        sessionList.innerHTML = results
          .map((result) => {
            const title = result.title || "Untitled";
            const directory = result.directory || "";
            const dirShort =
              directory.length > 40 ? "..." + directory.slice(-37) : directory;
            const timeFormatted = result.time_updated
              ? new Date(result.time_updated).toLocaleString()
              : "Unknown";

            // Format matches with highlighting
            const matchesHtml = result.matches
              .map((match) => {
                // Replace <<MATCH>> and <<END>> markers with <mark> tags
                const snippet = escapeHtml(match.snippet)
                  .replace(/&lt;&lt;MATCH&gt;&gt;/g, "<mark>")
                  .replace(/&lt;&lt;END&gt;&gt;/g, "</mark>");
                return `
                        <div class="match-snippet">
                            <div class="match-role">${match.role}</div>
                            <div>${snippet}</div>
                        </div>
                    `;
              })
              .join("");

            const moreMatches =
              result.total_matches > result.matches.length
                ? `<div style="font-size: 12px; color: var(--text-tertiary); margin-top: 8px;">
                         +${result.total_matches - result.matches.length} more matches
                       </div>`
                : "";

            // Build URL with search query parameter (and regex flag if enabled)
            let sessionUrl = `/session/${result.session_id}?q=${encodeURIComponent(query)}`;
            if (useRegex) sessionUrl += "&regex=true";

            return `
                    <div class="session-item" data-session-id="${result.session_id}">
                        <a href="${sessionUrl}" class="session-item-link">
                            <div class="session-header">
                                <div class="session-title">${escapeHtml(title)}</div>
                                <div class="session-time">${timeFormatted}</div>
                            </div>
                            <div class="session-meta">
                                <div class="meta-item">
                                    <span>ðŸ“‚</span>
                                    <span class="directory" title="${escapeHtml(directory)}">${escapeHtml(dirShort)}</span>
                                </div>
                            </div>
                            ${matchesHtml}
                            ${moreMatches}
                        </a>
                        <a href="#" class="archive-link" onclick="archiveSession('${result.session_id}', event)">Archive</a>
                    </div>
                `;
          })
          .join("");
      }

      function clearSearch() {
        searchInput.value = "";
        directorySelect.value = "";
        regexCheckbox.checked = false;
        searchInput.placeholder = "Search session contents...";
        sessionList.innerHTML = originalContent;
        clearBtn.classList.add("hidden");
        searchResultsHeader.classList.add("hidden");
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // Search on Enter key
      searchInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          performSearch();
        }
      });

      // Archive functionality
      async function archiveSession(sessionId, event) {
        event.preventDefault();
        event.stopPropagation();

        const link = event.target;
        link.textContent = "Archiving...";
        link.style.pointerEvents = "none";

        try {
          const response = await fetch(`/api/session/${sessionId}/archive`, {
            method: "POST",
          });

          if (response.ok) {
            // Remove the session from the list with animation
            const item = link.closest(".session-item");
            item.style.opacity = "0";
            item.style.transform = "translateX(-20px)";
            item.style.transition = "all 0.3s ease";

            setTimeout(() => {
              item.remove();
            }, 300);
          } else {
            link.textContent = "Archive";
            link.style.pointerEvents = "";
            console.error("Failed to archive session");
          }
        } catch (e) {
          link.textContent = "Archive";
          link.style.pointerEvents = "";
          console.error("Failed to archive:", e);
        }
      }

      // Sync index on demand
      async function syncIndex() {
        const btn = document.getElementById("syncBtn");
        btn.disabled = true;
        btn.textContent = "Syncing...";

        try {
          const response = await fetch("/api/sync", { method: "POST" });
          if (response.ok) {
            btn.textContent = "Synced âœ“";
            // Reload the page after a short pause so the session list refreshes
            setTimeout(() => {
              window.location.reload();
            }, 800);
          } else {
            btn.textContent = "Error";
            setTimeout(() => {
              btn.textContent = "Sync";
              btn.disabled = false;
            }, 2000);
          }
        } catch (e) {
          console.error("Sync failed:", e);
          btn.textContent = "Error";
          setTimeout(() => {
            btn.textContent = "Sync";
            btn.disabled = false;
          }, 2000);
        }
      }

      // Load directories on init
      loadDirectories();
    </script>
  </body>
</html>
